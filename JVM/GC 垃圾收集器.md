# GC 垃圾收集器

[TOC]

## 1. 判断对象存活算法

### 1.1. 引用计数算法

说明：在对象添加一个引用计数器，每当有一个地方引用它时，计数器就 +1；当引用失效时，计数器就 -1；任何时刻计数器为 0 时的对象就是不可能再被使用的。

缺点：无法回收循环引用的对象。（循环引用：即 `objA.instance = objeB.instance; objB.instance = objeA.instance;`） 

### 1.2. 可达性分析算法

说明：通过一系列称为 " GC Roots " 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程成为 " 引用链 " ，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图轮的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

#### 1.2.1. 固定可作为 GC Root 的对象

- 在虚拟机栈 ( 栈帧中的本地变量表 ) 中引用的对象，如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

- 在方法区中类静态属性引用的对象，如 Java 类的引用类型静态变量。

- 在方法去中常量引用的对象，如字符串常量池 ( String Table ) 里的引用

- 在本地方法栈中 JNI ( 即 `native `方法 ) 引用的对象。

- Java 虚拟机内部的引用，如基本数据类型对应的 Class对象，一些常驻的异常对象，以及系统类加载器。

- 所有被同步锁 ( `synchronized `关键字 ) 持有的对象。

- 反应 Java 虚拟机内部情况的 JMXBean , JVMTI 中注册的回调、本地代码缓存。

## 2. 引用类型

### 2.1. 强引用

说明：强引用是最传统的"引用"的定义，是指在程序代码之中普遍存在的引用复制，即类似 `Object obj = new Object()`这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。

### 2.2. 软引用

说明：软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 `SoftReference` 类来实现软引用。

### 2.3. 弱引用

说明：弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后提供 `WeakReference`类来实现弱引用。

### 2.4. 虚引用

说明：虚引用也成为 "幽灵引用" 或者 "幻影引用"，它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存事件构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后提供了 `PhantomReference` 类实现虚引用。

## 3. 垃圾收集算法

### 3.1. 分代收集理论

- 弱分代假说：绝大多数对象都是朝生夕灭的。

- 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

- 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

### 3.2. 垃圾收集算法分类

- 标记 - 清除算法

  说明：标记 - 清除算法分为 "标记" 和 "清除" 两个阶段：首先标记出所有需要回收的对象，在完成标记后，统一回收掉所有被标记对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。 

  缺点：

  1. 执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的这是必须进行大量标记和清除动作，导致标记和清除两个过程的执行效率都随对象的增长而降低。
  2. 内存空间碎片化的问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象是无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

- 标记 - 复制算法

  说明：它将可用内存按容量划分为大小相等的两块，每次只是用其中一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把一使用过的内存空间一次清理掉。

  优点：

  1. 不需要考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

  缺点：

  1. 这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费太多了。
  2. 如果内存中多数对象都是存活的，这种算法会产生大量的内存间复制的开销。

- 标记 - 整理算法

  说明：其中的标记过程仍然和 "标记 - 清除" 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都想内存空间一端移动，然后直接清理掉边界以外的内存。

#### 3.2.1. GC 分类

- 部分收集（ Partial GC ）：指目标不是完整收集整个 Java 堆的垃圾收集。
- 新生代收集（ Minor GC / Young GC ）：指目标只是新生代的垃圾收集。
- 老年代收集（ Major GC / Old GC ）：指目标只是老年代的垃圾收集。须区分是指老年代的收集还是整堆收集。
- 混合收集（ Mixed GC ）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。
- 整堆收集（ Full GC ）：整个 Java 堆和方法区的垃圾收集。
