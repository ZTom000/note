# GC 垃圾收集器

[TOC]

## 1. 判断对象存活算法

### 1.1. 引用计数算法

说明：在对象添加一个引用计数器，每当有一个地方引用它时，计数器就 +1；当引用失效时，计数器就 -1；任何时刻计数器为 0 时的对象就是不可能再被使用的。

缺点：无法回收循环引用的对象。（循环引用：即 `objA.instance = objeB.instance; objB.instance = objeA.instance;`） 

### 1.2. 可达性分析算法

说明：通过一系列称为 " GC Roots " 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程成为 " 引用链 " ，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图轮的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

#### 1.2.1. 固定可作为 GC Root 的对象

- 在虚拟机栈 ( 栈帧中的本地变量表 ) 中引用的对象，如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

- 在方法区中类静态属性引用的对象，如 Java 类的引用类型静态变量。

- 在方法去中常量引用的对象，如字符串常量池 ( String Table ) 里的引用

- 在本地方法栈中 JNI ( 即 `native `方法 ) 引用的对象。

- Java 虚拟机内部的引用，如基本数据类型对应的 Class对象，一些常驻的异常对象，以及系统类加载器。

- 所有被同步锁 ( `synchronized `关键字 ) 持有的对象。

- 反应 Java 虚拟机内部情况的 JMXBean , JVMTI 中注册的回调、本地代码缓存。

## 2. 引用类型

### 2.1. 强引用

说明：强引用是最传统的"引用"的定义，是指在程序代码之中普遍存在的引用复制，即类似 `Object obj = new Object()`这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。

### 2.2. 软引用

说明：软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 `SoftReference` 类来实现软引用。

### 2.3. 弱引用

说明：弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后提供 `WeakReference`类来实现弱引用。

### 2.4. 虚引用

说明：虚引用也成为 "幽灵引用" 或者 "幻影引用"，它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存事件构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后提供了 `PhantomReference` 类实现虚引用。

## 3. 垃圾收集算法

### 3.1. 分代收集理论

- 弱分代假说：绝大多数对象都是朝生夕灭的。

- 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

- 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

### 3.2. 垃圾收集算法分类

- 标记 - 复制算法

- 标记 - 清除算法

- 标记 - 整理算法

#### 3.2.1. GC 分类

- 部分收集（ Partial GC ）：指目标不是完整收集整个 Java 堆的垃圾收集。
- 新生代收集（ Minor GC / Young GC ）：指目标只是新生代的垃圾收集。
- 老年代收集（ Major GC / Old GC ）：指目标只是老年代的垃圾收集。须区分是指老年代的收集还是整堆收集。
- 混合收集（ Mixed GC ）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。
- 整堆收集（ Full GC ）：整个 Java 堆和方法区的垃圾收集。
